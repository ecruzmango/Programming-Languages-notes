
# Introduction to Programming Languages

* Declarative
* Functional: Lisp/Scheme, Ocaml, Haskell, Elixir, Erlang
* Dataflow: Id, Val
* Logic, Constraint: Prolog, Excel, SQL
* Imperative
* von Neumann: C, Ada, Fortran
* Object-oriented: Smalltalk, Eiffel, Java, C#, C++
* Scripting: PERL, PHP, Python, Javascript

### Classification:

Imperative vs Declarative (in an analogy):

Imagine you want a sandwich made. With an imperative approach, you would tell someone exactly HOW to make it with specific steps:

1. Take two slices of bread from the bag
2. Open the jar of peanut butter
3. Using a knife, spread peanut butter on one slice
4. Open the jar of jelly
5. Spread jelly on the other slice
6. Put the slices together

With a declarative approach, you would simply specify WHAT you want:
"I want a peanut butter and jelly sandwich"
This fundamental difference - focusing on HOW versus WHAT - is the key distinction between imperative and declarative programming.

__Declarative Examples__:

* Functional: Lisp/Scheme, Ocaml, Haskell, Elixir, Erlang
*  Dataflow: Id, Val
* Logic, Constraint: Prolog, Excel, SQL

__Imperative Examples__:

* von Neumann: C, Ada, Fortran
* Object-oriented: Smalltalk, Eiffel, Java, C#, C++
* Scripting: PERL, PHP, Python, Javascript


### Functional Languages (Haskell): 

Functional languages use a computational model of recursive
definition of functions.

 Inspired by lambda calculus.

 That is, functions act like mathematical functions.

 They take in data and produce an output.

 Tends to lead to much simpler, but many more functions.


* A computer just solves a problem and be used for mechanical, electrical, physical, and abstract



### Assembly:

* assembly was the first abstraction of writing machine code

* It was human-readable (arguably). It was strictly imperative. You told the computer how to calculate something.

### "Coding":


### C# [created in 2000] 
Attributes:

o compiled

o object-oriented

o virtual machine (.NET)

o procedural (imperative)

* Emphasizes rapid and large-scale development
*  C# is fully portable now

o MSFT supports Mac and Linux via "dotnet"

o Third-party Mono


### Haskell (.hs) [created in 1989]
Attributes:

o purely functional

o compiled

* Emphasizes reliability and bug reduction at time of writing code

### Rust (.rs) [created in 2010]
Attributes:

• compiled (has an interpreted option)

o blended: imperative and/or functional

Systems language:

• Emphasizes safety

• Ensures your memory is valid when it is accessed

• Has an unsafe mode, where YOU enforce safety/compliance.

